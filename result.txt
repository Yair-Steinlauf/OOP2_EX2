==================================================
HEADER FILES (.h) FROM INCLUDE DIRECTORY
==================================================

File: Address.h
--------------------------------------------------
#pragma once
#include <iostream>
class Address {
private:
	std::string m_street , m_city;
	int m_number;
public:
	// Getters
	std::string getCity() const;
	std::string getStreet() const;
	int getNumber() const;


	Address(std::string street = "", std::string city = "", int number = 0);
	Address(const Address& other);
	Address& operator=(const Address& other);
	bool operator==(const Address& other) const;
	bool operator!=(const Address& other) const;
	~Address() = default;
};
 std::istream& operator>>(std::istream& is, Address& address);
 std::ostream& operator<<(std::ostream& os, const Address& address);

File: AddressValidator.h
--------------------------------------------------
#pragma once

#include "Address.h"

class AddressValidator {
public:
	static bool validate(const Address& address);
	static std::string getError();
};

File: BaseField.h
--------------------------------------------------
#pragma once
#include "SFML/Graphics.hpp"
#include "Text.h"



class BaseField{
protected:
	Text m_text;
	sf::RectangleShape m_rect;
	bool m_isClicked = false;
	

public:
	BaseField(sf::Vector2f location = sf::Vector2f(0,0));
	void setLocation(sf::Vector2f newLocation);
	void handleInput(sf::Event event);
	bool contains(sf::Vector2f location);
	virtual void draw(sf::RenderWindow& window);
	void onPressClick();
	void onReleaseClick();
	void setText(const std::string text);
	virtual ~BaseField() = default;


};


File: BaseValidator.h
--------------------------------------------------
#pragma once
#include <string>

class AddressValidator;
class IDValidator;
class EmailValidator;
class DateValidator;

template <typename Type>


class BaseValidator {
public:
	static virtual bool validate(const Type& object) {
		return false;
	}
	virtual ~BaseValidator() = default;
	static virtual std::string getError() { return ""; }
};



File: BookingForm.h
--------------------------------------------------
﻿#ifndef BOOKINGFORM_H
#define BOOKINGFORM_H

#include <SFML/Graphics.hpp>
#include <vector>
#include <string>
#include <array>
#include <Text.h>
#include <DataLoader.h>
#include <memory>
#include <Field.h>
#include "NameValidator.h"



class DialogueManager;

struct PersonalInfo {
    std::string name;
    std::string id;
    std::string address;
    std::string email;
};

class BookingForm {
protected:
	std::vector<Text> m_textFields;
    std::vector<std::unique_ptr<BaseField>> m_inputFields;
    std::vector<std::string> fieldLabels;
    std::vector<std::string> userInput;
    std::size_t activeField = -1;
    sf::Clock cursorTimer;
    bool showCursor = true;

    sf::RenderWindow& window;
    DialogueManager* formManager;
    PersonalInfo personalInfo;

    virtual void setDefaultValues()=0 ;
    void openConfirmationWindow();
    virtual std::vector<std::string> validate() = 0;

public:
    BookingForm(sf::RenderWindow& win, DialogueManager* manager);
    virtual ~BookingForm() = default;
    virtual std::string getFormType() const = 0;
    virtual void render(sf::RenderWindow& window) = 0;
    virtual void handleInput(sf::Event event) = 0;
};

#endif // BOOKINGFORM_H


File: Button.h
--------------------------------------------------
#pragma once
#include "Text.h"

class Button{
protected:
	Text m_text;
	sf::RectangleShape m_rectangle;
	bool m_isClicked = false;
public:
	Button(const Text& text = Text());
	virtual bool contains(sf::Vector2f& coords);
	void draw(sf::RenderWindow& window);
	virtual void onClick() = 0;
	virtual void update() = 0;
	~Button() = default;
};



File: CarRentalForm.h
--------------------------------------------------
// CarRentalForm.h - Handles Car Rental Bookings
#ifndef CARRENTALFORM_H
#define CARRENTALFORM_H

#include "BookingForm.h"
#include <array>
#include <vector>
#include "SelectionField.h"
#include "ConfirmationBtn.h"

class CarRentalForm : public BookingForm {
public:
    CarRentalForm(sf::RenderWindow& win, DialogueManager* manager);    
    std::string getFormType() const override;
    void render(sf::RenderWindow& window) override;
    void handleInput(sf::Event event) override;
private:
    std::vector<std::string> validate() override;
    std::string pickupLocation, dropOffLocation, carType;
    void setDefaultValues();
    std::array<std::string, 5> carTypeSelection = { "Economy","Compact","Sedan","SUV","Luxury"};
    int selectedCarType = 0;
    SelectionField m_selectionField;
    ConfirmationBtn m_Done;
    ConfirmationBtn m_Cancel;
};

#endif // CARRENTALFORM_H


File: ConfimationWindow.h
--------------------------------------------------
#pragma once
#include "BookingForm.h"
#include "ConfirmationBtn.h"




class ConfimationWindow {
public:
    ConfimationWindow(std::string title,
        const std::vector<std::string>& texts,
        const std::vector<std::string>& fields,
        const std::vector<std::string>& errors,
        const std::vector<std::string>& specialErrors
    );
    void render();

private:   
    std::string formTitle;
    std::vector<Text> m_texts;
    ConfirmationBtn m_approve;
    ConfirmationBtn m_cancel;
    bool approved = true;
};

File: ConfirmationBtn.h
--------------------------------------------------
#pragma once
#include "Button.h"

class ConfirmationBtn : public Button
{
public:
	ConfirmationBtn(std::string text = "Done", sf::Vector2f location = sf::Vector2f(0, 0), sf::Color color = sf::Color(50, 150, 50));
	~ConfirmationBtn() = default;
	void update() override;
	void onClick() override;
private:

};


File: DataLoader.h
--------------------------------------------------
#pragma once
#include "SFML/Graphics.hpp"

class DataLoader
{
public:
    static DataLoader& Init();
    DataLoader(const DataLoader&) = delete;
    void operator=(const DataLoader&) = delete;
    static sf::Font& getP2Font();

private:
    DataLoader();
    sf::Font m_font;
};

File: DatabaseManager.h
--------------------------------------------------
// DatabaseManager.h - Handles Storing and Retrieving Booking Data
#ifndef DATABASEMANAGER_H
#define DATABASEMANAGER_H

#include <string>
#include <vector>

class DatabaseManager {
public:
    void saveBookingData(const std::string& bookingData);
    std::vector<std::string> loadBookings();
};

#endif // DATABASEMANAGER_H


File: Date.h
--------------------------------------------------
#pragma once
#include <iostream>
class Date {
private:
	int m_day, m_month, m_year;
public:
	Date(int day = 1, int month = 1, int year = 2000);
	Date(const Date& other);
	int getDay() const;
	int getMonth() const;
	int getYear() const;
	Date& operator=(const Date& other);	
	bool operator==(const Date& other) const;	
	bool operator!=(const Date& other) const;
	~Date() = default;
};

std::istream& operator>>(std::istream& is, Date& date);
std::ostream& operator<<(std::ostream& os, const Date& date); 

File: DateValidator.h
--------------------------------------------------
#pragma once
#include "Date.h"
#include "BaseValidator.h"

class DateValidator : public BaseValidator<Date> {
public:
	bool validate(const Date& date) const;
};

File: DialogueManager.h
--------------------------------------------------
#ifndef DIALOGUEMANAGER_H
#define DIALOGUEMANAGER_H

#include "BookingForm.h"
#include <SFML/Graphics.hpp>
#include <memory>
#include <iostream>

class DialogueManager {
private:
    std::unique_ptr<BookingForm> activeForm;
    sf::RenderWindow formWindow;
    bool isFormOpen;

public:
    DialogueManager();
    void setActiveForm(std::unique_ptr<BookingForm> form);
    void handleFormEvents();
    void closeForm();
};

#endif // DIALOGUEMANAGER_H


File: EmailValidator.h
--------------------------------------------------
#pragma once

class EmailValidator {
public:
	static bool validate(const std::string& email) ;
	static std::string getError();

};

File: Engine.h
--------------------------------------------------
﻿#ifndef ENGINE_H
#define ENGINE_H

#include <SFML/Graphics.hpp>
#include "UIManager.h"
#include "DialogueManager.h"

class Engine {
private:
    sf::RenderWindow window;
    UIManager uiManager;
    DialogueManager dialogueManager;

public:
    Engine();
    void run();  
};

#endif // ENGINE_H


File: EventBookingForm.h
--------------------------------------------------
#ifndef EVENTBOOKINGFORM_H
#define EVENTBOOKINGFORM_H

#include "BookingForm.h"

class EventBookingForm : public BookingForm {
public:
    EventBookingForm(sf::RenderWindow& win, DialogueManager* manager);
    std::string getFormType() const override;
    void render(sf::RenderWindow& window) override;
    void handleInput(sf::Event event) override;
private:
    void setDefaultValues() override;
    std::array<std::string, 5> SeatingTypeSelection = { "General Admission", "Front Row", "VIP Section", "Aisle Seat" };
    int selectedSeatingType = 0;
};

#endif // EVENTBOOKINGFORM_H


File: Field.h
--------------------------------------------------
#pragma once
#include "BaseField.h"
#include "BaseValidator.h"



template<typename Validator, typename Type>
class Field : public BaseField {
private:
	Type m_data;
	Validator m_validator;
public:
	Field(Type data , sf::Vector2f location = sf::Vector2f(0, 0))
	: BaseField(location){
		m_data = data;
	}

	std::string getError();
};

template<typename Validator, typename Type>
inline std::string Field<Validator, Type>::getError()
{
	if (Validator::validate(m_data))
		return "";
	return Validator::getError();
}


File: FlightBookingForm.h
--------------------------------------------------
﻿#ifndef FLIGHTBOOKINGFORM_H
#define FLIGHTBOOKINGFORM_H

#include "BookingForm.h"
#include <SFML/Graphics.hpp>

class FlightBookingForm : public BookingForm {
private:    
    void setDefaultValues() override;
    
    std::array<std::pair<std::string, bool>, 5> timeSelection = {
        std::make_pair("Morning", false),
        std::make_pair("Noon", false),
        std::make_pair("Evening", false),
        std::make_pair("Night", false),
        std::make_pair("Don'Type Care", true)  // ✅ Default selection
    };

public:
    FlightBookingForm(sf::RenderWindow& win, DialogueManager* manager);  // ✅ Updated constructor
    std::string getFormType() const override;
    void render(sf::RenderWindow& window) override;
    void handleInput(sf::Event event) override;
};

#endif // FLIGHTBOOKINGFORM_H


File: HotelBookingForm.h
--------------------------------------------------
#ifndef HOTELBOOKINGFORM_H
#define HOTELBOOKINGFORM_H

#include "BookingForm.h"
class HotelBookingForm : public BookingForm {
public:
    HotelBookingForm(sf::RenderWindow& win, DialogueManager* manager);
    std::string getFormType() const override;
    void render(sf::RenderWindow& window) override;
    void handleInput(sf::Event event) override;
private:
    void setDefaultValues() override;
    std::array<std::string, 4> roomTypeSelection = {"Single Room","Double Room","Family Room","Presidential Suite"};
	int selectedRoomType = 0;

};

#endif // HOTELBOOKINGFORM_H


File: IDValidator.h
--------------------------------------------------
#pragma once
#include "string"
class IDValidator
{
public:
	static bool validate(const uint32_t& fieldToValidate);
	static std::string getError();

	
};

File: Logger.h
--------------------------------------------------
#pragma once
// Logger.h - Handles System Logging
#ifndef LOGGER_H
#define LOGGER_H

#include <fstream>
#include <string>
#include <mutex>
#include <ctime>
#include <iostream>

class Logger {
private:
    static Logger* instance;
    static std::mutex mutex;
    std::ofstream logFile;
    Logger(); // Private constructor to prevent direct instantiation
    Logger(Logger& other) = delete;  //Done: deleted copy constructor
    Logger& operator=(Logger& other) = delete; //Done: deleted assing operator
    

public:
    static Logger* getInstance();
    void log(const std::string& message);
    ~Logger();
};

#endif // LOGGER_H

File: NameValidator.h
--------------------------------------------------
#pragma once
#include <string>

class NameValidator  {
public:
	static bool validate(const std::string& name);
	static std::string getError();
};


File: NotificationSystem.h
--------------------------------------------------
// NotificationSystem.h - Handles Sending Notifications
#ifndef NOTIFICATIONSYSTEM_H
#define NOTIFICATIONSYSTEM_H

#include <string>

class NotificationSystem {
public:
    void sendNotification(const std::string& message);
};

#endif // NOTIFICATIONSYSTEM_H


File: SelectionButton.h
--------------------------------------------------
#pragma once
#include "Button.h"

class SelectionButton : public Button
{
public:
	SelectionButton(const std::string& text, sf::Vector2f location);
	void setClick(bool input) ;
	~SelectionButton() = default;
	void update();
	void onClick();
	std::string getText();
private:

};


File: SelectionField.h
--------------------------------------------------
#pragma once
#include "SFML/Graphics.hpp"
#include "Text.h"
#include "Field.h"
#include "SelectionButton.h"
#include "vector"
#include "memory"
class SelectionField {
private:
	std::unique_ptr<BaseField> m_field;
	std::vector<std::unique_ptr<SelectionButton>> m_buttons;
public:
	SelectionField(std::unique_ptr<BaseField> field , std::vector<std::unique_ptr<SelectionButton>> buttons);
	SelectionField();
	void update(const sf::Time& time);
	bool contains(sf::Vector2f& coords);
	void draw(sf::RenderWindow& window);
	void handleEvent(sf::Event& event);

};

File: Text.h
--------------------------------------------------
#pragma once
#include <SFML/Graphics.hpp>
#include <string>
#include <iostream>
#include "DataLoader.h"
class Text{
private:
	sf::Text m_text;
public:
	Text(std::string text = "", sf::Vector2f location = sf::Vector2f(0, 0) ,
		sf::Color color = sf::Color(60, 60, 60), sf::Text::Style style = sf::Text::Style::Regular
		, unsigned int characterSize = 18);
	void draw(sf::RenderWindow& window);
	void setText(std::string text);
	void setLocation(sf::Vector2f newLocation);
	void setFillColor(const sf::Color& color);
	sf::Text& getText();
	std::string getString();
};

File: TrainBookingForm.h
--------------------------------------------------
﻿#ifndef TRAINBOOKINGFORM_H
#define TRAINBOOKINGFORM_H

#include "BookingForm.h"

class TrainBookingForm : public BookingForm {
public:
    TrainBookingForm(sf::RenderWindow& win, DialogueManager* manager);
    std::string getFormType() const override;
    void render(sf::RenderWindow& window) override;
    void handleInput(sf::Event event) override;
private:
    void setDefaultValues() override; 
    std::array<std::pair<std::string, bool>, 5> timeSelection = {
            std::make_pair("Morning", false),
            std::make_pair("Noon", false),
            std::make_pair("Evening", false),
            std::make_pair("Night", false),
            std::make_pair("Don'Type Care", true)  // ✅ Default selection
    };
    std::array<std::pair<std::string, bool>, 4> specialSelection = {
        std::make_pair("Quiet Zone", false),
        std::make_pair("Family Section", false),
        std::make_pair("First Class", false) ,
        std::make_pair("None", true)
    };
};

#endif // TRAINBOOKINGFORM_H


File: UIManager.h
--------------------------------------------------
﻿#ifndef UIMANAGER_H
#define UIMANAGER_H

#include <SFML/Graphics.hpp>
#include "DialogueManager.h"

class UIManager {
private:
    sf::RenderWindow& window;
    DialogueManager& formManager;

    // ✅ Fix: Declare buttons and texts
    sf::Font font;
    //TODO: לבנות מחלקת כפתתור, הכוללת מרובע וטקסט
    sf::RectangleShape buttonFlight, buttonHotel, buttonCar, buttonEvent, buttonTrain;
    sf::Text textFlight, textHotel, textCar, textEvent, textTrain;
    
    // ✅ Fix: Declare setupButton
    void setupButton(sf::RectangleShape& button, sf::Text& text, const std::string& label, float y);

public:
    UIManager(sf::RenderWindow& win, DialogueManager& dManager);
    void handleEvent(const sf::Event& event);
    void render();
};

#endif // UIMANAGER_H


==================================================
SOURCE FILES (.cpp) FROM SRC DIRECTORY
==================================================

File: Address.cpp
--------------------------------------------------
#include "Address.h"
#include <string>

std::string Address::getCity() const
{
	return m_city;
}

std::string Address::getStreet() const
{
	return m_street;
}

int Address::getNumber() const
{
	return m_number;
}



Address::Address(std::string street, std::string city, int number)
{
	m_street = street;
	m_city = city;
	m_number = number;
}

Address::Address(const Address& other)
{
	*this = other;
}

Address& Address::operator=(const Address& other)
{
	if (this != &other)
	{
		m_street = other.m_street;
		m_city = other.m_city;
		m_number = other.m_number;
	}
	return *this;
}
std::istream& operator>>(std::istream& is, Address& address)
{
	std::string street, city;
	int number;
	std::string line;
	is >> line;
	
	size_t firstDash = line.find('-');
	size_t secondDash = line.find('-', firstDash + 1);

	if (firstDash != std::string::npos && secondDash != std::string::npos) {
		street = line.substr(0, firstDash);
		number = std::stoi(line.substr(firstDash + 1, secondDash - firstDash - 1));
		city = line.substr(secondDash + 1);
	}
	address = Address(street, city, number);
	return is;
}
std::ostream& operator<<(std::ostream& os, const Address& address)
{
	os << address.getStreet() << ", " <<  address.getNumber() << ", " << address.getCity() ;
	return os;
}
bool Address::operator==(const Address& other) const
{
	return (m_street == other.m_street && m_city == other.m_city && m_number == other.m_number);
}

bool Address::operator!=(const Address& other) const
{
	return !(*this == other);
}


File: AddressValidator.cpp
--------------------------------------------------
#include "AddressValidator.h"
#include "NameValidator.h"


bool AddressValidator::validate(const Address& address)
{
	bool isCityValid = NameValidator::validate(address.getCity());
	bool isStreetValid = NameValidator::validate(address.getStreet());
	bool isCityValid = address.getNumber() > 0;
	return isCityValid && isStreetValid && isCityValid;
}

std::string AddressValidator::getError()
{
	return "Adress not valid";
}


File: BaseField.cpp
--------------------------------------------------
#include "BaseField.h"

BaseField::BaseField(sf::Vector2f location)
    :m_text(Text("",location))
{
    
    m_rect.setSize(sf::Vector2f(250, 35));
    m_rect.setPosition(location);
    m_rect.setFillColor(sf::Color::White);
    m_rect.setOutlineThickness(2);
    m_rect.setOutlineColor(sf::Color(160, 160, 160));
}

void BaseField::setLocation(sf::Vector2f newLocation)
{
    m_rect.setPosition(newLocation);
    m_text.setLocation(newLocation);
}

void BaseField::handleInput(sf::Event event)
{
    
    if (event.type == sf::Event::TextEntered) {        
        std::string text = m_text.getText().getString();
        if (event.text.unicode == '\b' && !m_text.getText().getString().isEmpty() ) {            
            text.resize(text.size() - 1);
        }
        else if (event.text.unicode >= 32 && event.text.unicode < 128) {            
            text += static_cast<char>(event.text.unicode);
        }
        m_text.setText(text);
    }

}

bool BaseField::contains(sf::Vector2f location)
{
    if (m_rect.getGlobalBounds().contains(location)) {
        return true;
    }
    return false;
}

void BaseField::draw(sf::RenderWindow& window)
{
    window.draw(m_rect);
    m_text.draw(window);
}

void BaseField::onPressClick()
{
    m_isClicked = true;    
    m_rect.setOutlineColor(sf::Color(0, 120, 255));
// TODO cursur
}

void BaseField::onReleaseClick()
{
    m_isClicked = false;
    m_rect.setOutlineColor(sf::Color(160, 160, 160));
}

void BaseField::setText(const std::string text)
{
    m_text.setText(text);
}


File: BookingForm.cpp
--------------------------------------------------
﻿#include "BookingForm.h"
#include "DialogueManager.h"
#include <iostream>
#include <ctime>  // For getting current date
#include "AddressValidator.h"
#include "IDValidator.h"
#include "EmailValidator.h"
#include "DateValidator.h"


BookingForm::BookingForm(sf::RenderWindow& win, DialogueManager* manager) :window(win), formManager(manager) {
    fieldLabels = { "Name:", "ID:", "Address:", "Email:" };
    //TODO להוסיף כפתורים        
    m_inputFields.push_back(std::make_unique<Field<NameValidator, std::string>>(""));
    m_inputFields.push_back(std::make_unique<Field<IDValidator, uint32_t>>(0));
    m_inputFields.push_back(std::make_unique<Field<AddressValidator, Address>>(Address()));
    m_inputFields.push_back(std::make_unique<Field<EmailValidator, std::string>>(""));
    
    int yOffset = 60;
    for (std::size_t i = 0; i < fieldLabels.size(); ++i) {
        m_textFields.push_back(Text(fieldLabels[i], sf::Vector2f(20, yOffset)));
        m_inputFields[i].get()->setLocation(sf::Vector2f(250, yOffset));
        yOffset += 50;
    }
    
}

void BookingForm::openConfirmationWindow() {
    const std::string& formTitle = getFormType();
    sf::RenderWindow confirmWindow(sf::VideoMode(500, 600), "Confirm " + formTitle);

    sf::Font font;
    font.loadFromFile("C:/Windows/Fonts/arialbd.ttf");

    bool approved = false;

    while (confirmWindow.isOpen()) {
        sf::Event event;
        while (confirmWindow.pollEvent(event)) {
            if (event.type == sf::Event::Closed)
                confirmWindow.close();

            sf::Vector2f mousePos(event.mouseButton.x, event.mouseButton.y);

            if (event.type == sf::Event::MouseButtonPressed) {
                if (mousePos.x >= 280 && mousePos.x <= 400 && mousePos.y >= 300 && mousePos.y <= 345) {
                    confirmWindow.close();
                }
                if (mousePos.x >= 100 && mousePos.x <= 220 && mousePos.y >= 300 && mousePos.y <= 345) {
                    std::cout << formTitle << " Confirmed! Returning to main menu." << std::endl;
                    approved = true;
                    confirmWindow.close();
                }
            }
        }

        confirmWindow.clear(sf::Color(240, 240, 240));

        sf::Text title("Confirm " + formTitle, font, 22);
        title.setFillColor(sf::Color::Black);
        title.setStyle(sf::Text::Bold);
        title.setPosition(130, 20);
        confirmWindow.draw(title);

        std::string bookingInfo;
        for (size_t i = 0; i < fieldLabels.size(); ++i) {
            bookingInfo += fieldLabels[i] + " " + userInput[i] + "\n";
        }

        sf::Text details(bookingInfo, font, 18);
        details.setFillColor(sf::Color::Black);
        details.setPosition(50, 80);
        confirmWindow.draw(details);

        // ✅ Approve Button
        sf::RectangleShape approveButton(sf::Vector2f(120, 40));
        approveButton.setPosition(100, 300);
        approveButton.setFillColor(sf::Color(50, 150, 50));
        confirmWindow.draw(approveButton);

        sf::Text approveText("APPROVE", font, 18);
        approveText.setFillColor(sf::Color::White);
        approveText.setPosition(118, 310);
        confirmWindow.draw(approveText);

        // ✅ Cancel Button
        sf::RectangleShape cancelButton(sf::Vector2f(120, 40));
        cancelButton.setPosition(280, 300);
        cancelButton.setFillColor(sf::Color(180, 0, 0));
        confirmWindow.draw(cancelButton);

        sf::Text cancelText("CANCEL", font, 18);
        cancelText.setFillColor(sf::Color::White);
        cancelText.setPosition(305, 310);
        confirmWindow.draw(cancelText);

        confirmWindow.display();
    }

    if (approved) {
        formManager->closeForm();
    }
}


File: Button.cpp
--------------------------------------------------
#include "Button.h"

//Button::Button(const std::string& text, 
//	unsigned int characterSize ,sf::Vector2f size)
//	: m_text(Text(text, location, sf::Color::White))
//{
//	m_rectangle.setSize(size);
//	m_rectangle.setFillColor(fillColor);
//	m_rectangle.setPosition(location);
//}

Button::Button(const Text& text)
	:m_text(text)
{
}

bool Button::contains(sf::Vector2f& coords)
{
	if (m_rectangle.getGlobalBounds().contains(coords))
		return true;
	return false;
}

void Button::draw(sf::RenderWindow& window)
{
	window.draw(m_rectangle);
	m_text.draw(window);
}


File: CarRentalForm.cpp
--------------------------------------------------
﻿#include "CarRentalForm.h"
#include "DialogueManager.h"
#include "ConfimationWindow.h"
#include <iostream>
#include <ctime>  // For getting current date

CarRentalForm::CarRentalForm(sf::RenderWindow& win, DialogueManager* manager)
    : BookingForm(win, manager) {  // ✅ Calls base constructor
    fieldLabels.insert(fieldLabels.end(), {
        "Pickup Location:",
        "Pickup Date:", "Rent total days:",
        "GPS needed?", "Child Seat needed?",
        "Car Type:"
        });

    // add field:

    m_inputFields.push_back(std::make_unique<Field<NameValidator, std::string>>(""));
    m_inputFields.push_back(std::make_unique<Field<NameValidator, std::string>>(""));
    m_inputFields.push_back(std::make_unique<Field<NameValidator, std::string>>(""));
    m_inputFields.push_back(std::make_unique<Field<NameValidator, std::string>>(""));
    m_inputFields.push_back(std::make_unique<Field<NameValidator, std::string>>(""));
    m_inputFields.push_back(std::make_unique<Field<NameValidator, std::string>>(""));
    
    std::vector<std::unique_ptr<SelectionButton>> selectionButton;
    



    int yOffset = 60 + 50 * m_textFields.size();
    for (int i = m_textFields.size(); i < fieldLabels.size(); i++) {
        m_textFields.push_back((Text(fieldLabels[i], sf::Vector2f(20, yOffset))));
        m_inputFields[i].get()->setLocation(sf::Vector2f(250, yOffset));
        yOffset += 50;
    }


   yOffset -= 10;
   float carTypeButtonX = 20;
   for (int i = 0; i < carTypeSelection.size(); ++i) {
       selectionButton.push_back(std::make_unique<SelectionButton>(carTypeSelection[i], sf::Vector2f(carTypeButtonX, yOffset)));
       carTypeButtonX += 105;  // ✅ Increased spacing

   }
   auto field = std::move(m_inputFields.back());
   m_inputFields.pop_back();
   m_selectionField = SelectionField(std::move(field), std::move(selectionButton));

   int buttonY = yOffset + 40;
   m_Done = ConfirmationBtn( "Done", sf::Vector2f(20, buttonY), sf::Color(50,150,50));
   m_Cancel = ConfirmationBtn("Cancel", sf::Vector2f(200, buttonY), sf::Color(180,0,0));
   //    sf::RectangleShape roomButton(sf::Vector2f(90, 30));
   //    roomButton.setPosition(carTypeButtonX, yOffset);
   //    roomButton.setFillColor(selectedCarType == i ? sf::Color(0, 120, 255) : sf::Color::White);  // ✅ Highlight selected
   //    roomButton.setOutlineThickness(2);
   //    roomButton.setOutlineColor(sf::Color(160, 160, 160));
   //    window.draw(roomButton);

   //    sf::Text roomText(carTypeSelection[i], font, 16);
   //    roomText.setFillColor(selectedCarType == i ? sf::Color::White : sf::Color::Black);
   //    roomText.setPosition(carTypeButtonX+10, yOffset + 5);
   //    window.draw(roomText);
  }



void CarRentalForm::setDefaultValues() {
    time_t now = time(0);
    tm ltm;
    localtime_s(&ltm, &now);  

    userInput[5] = std::to_string(1900 + ltm.tm_year) + "-" +
        std::to_string(1 + ltm.tm_mon) + "-" +
        std::to_string(ltm.tm_mday);
	userInput[9] = "Economy";
}

std::string CarRentalForm::getFormType() const {
    return "Car Rental";
}

void CarRentalForm::render(sf::RenderWindow& window) {
    sf::Font font;
    font.loadFromFile("C:/Windows/Fonts/arialbd.ttf");

    window.clear(sf::Color(235, 235, 235));

    // ✅ Title
    sf::Text title("Car Rental Form", font, 26);
    title.setFillColor(sf::Color(20, 20, 20));
    title.setStyle(sf::Text::Bold);
    title.setPosition(20, 10);
    window.draw(title);

    bool cursorVisible = (cursorTimer.getElapsedTime().asMilliseconds() % 1000 < 500);

    for (auto& object : m_inputFields) {
        object.get()->draw(window);
    }
    for (auto& object : m_textFields) {
        object.draw(window);
    }
    m_selectionField.draw(window);
    m_selectionField.update(cursorTimer.getElapsedTime());

    m_Done.draw(window);
    m_Cancel.draw(window);
    // ✅ Render input fields dynamically
   int yOffset = 60;
   for (std::size_t i = 0; i < fieldLabels.size(); ++i) {
        yOffset += 50;
    }
  
}

void CarRentalForm::handleInput(sf::Event event) {
    sf::Vector2f mousePos(event.mouseButton.x, event.mouseButton.y);
    if (event.type == sf::Event::MouseButtonPressed) {

        for (int i = 0; i < m_inputFields.size(); i++)
        {
            m_inputFields[i].get()->onReleaseClick();
            if (m_inputFields[i].get()->contains(mousePos)) {
                activeField = i;
                m_inputFields[i].get()->onPressClick();
            }
        }
        if (m_selectionField.contains(mousePos))
            m_selectionField.handleEvent(event);

        if (m_Cancel.contains(mousePos))
            window.close();
        if (m_Done.contains(mousePos)) {
            ConfimationWindow confirmationWindow("Confirm Car Rental", m_inputFields, );
        }


    }
    if (event.type == sf::Event::TextEntered) {
        m_inputFields[activeField].get()->handleInput(event);
    }

    
    // TODO: אם מישהו נלחץ לשנות את שאר הצבעים בחזרה לרגיל.


   /* if (event.type == sf::Event::TextEntered) {
        if (event.text.unicode == '\b' && !userInput[activeField].empty()) {
            userInput[activeField].pop_back();
        }
        else if (event.text.unicode >= 32 && event.text.unicode < 128) {
            userInput[activeField] += static_cast<char>(event.text.unicode);
        }
    }*/
   /* else if (event.type == sf::Event::KeyPressed) {
        if (event.key.code == sf::Keyboard::Tab) {
            activeField = (activeField + 1) % userInput.size();
        }
        if (event.key.code == sf::Keyboard::Return) {
            std::cout << "Entered Data: ";
            for (const auto& field : userInput) std::cout << field << " ";
            std::cout << std::endl;
        }
    }*/
    //else if (event.type == sf::Event::MouseButtonPressed) {
    //    sf::Vector2f mousePos(event.mouseButton.x, event.mouseButton.y);
    //    int yOffset = 60;

    //    for (std::size_t i = 0; i < fieldLabels.size(); ++i) {
    //        sf::FloatRect inputBoxBounds(240, yOffset - 5, 250, 35);
    //        if (inputBoxBounds.contains(mousePos)) {
    //            activeField = i;
    //            return;
    //        }
    //        yOffset += 50;
    //    }
    //    yOffset -= 10;
    //    // ✅ Handle Car Type Button Click          
    //    float carTypeButtonX = 20;
    //    for (int i = 0; i < carTypeSelection.size(); ++i) {
    //        sf::FloatRect timeButtonBounds(carTypeButtonX, yOffset, 90, 30);
    //        if (timeButtonBounds.contains(mousePos)) {
    //            selectedCarType = i;
    //            //Update the "Car Type" input box
    //            userInput[9] = carTypeSelection[i];

    //            return;
    //        }
    //        carTypeButtonX += 105;  // Move to next button
    //    }
    //     yOffset += 40;

        /*if (mousePos.x >= 20 && mousePos.x <= 160 && mousePos.y >= yOffset && mousePos.y <= yOffset + 40) {
            std::cout << "Car Rental Confirmed!\n";
            openConfirmationWindow();
            return;
        }

        if (mousePos.x >= 200 && mousePos.x <= 340 && mousePos.y >= yOffset && mousePos.y <= yOffset + 40) {
            std::cout << "Cancelled Car Rental\n";
            formManager->closeForm();
            return;
        }*/
    //}
}

std::vector<std::string> CarRentalForm::validate()
{
    std::vector<std::string> errors;
    for (auto& field : m_inputFields) {
        errors.push_back(field.get().getError());
    }
    return std::vector<std::string>();
}




File: ConfimationWindow.cpp
--------------------------------------------------
#include "ConfimationWindow.h"

ConfimationWindow::ConfimationWindow(std::string formTitle,
	const std::vector<std::string>& texts,
	const std::vector<std::string>& fields,
	const std::vector<std::string>& errors,
	const std::vector<std::string>& specialErrors
) : formTitle(formTitle)
{

	Text title("Confirm " + formTitle, sf::Vector2f(130, 20), sf::Color::Black, sf::Text::Bold, 22);
	m_texts.push_back(title);
	int yOffset = 80;
	for (int i = 0; i < texts.size(); i++)
	{
		Text text(texts[i] + " " + fields[i], sf::Vector2f(50, yOffset), sf::Color::Black);
		m_texts.push_back(text);
		if (errors[i] != "") {
			approved = false;
			yOffset += 30;
			Text error(errors[i], sf::Vector2f(50, yOffset), sf::Color::Red, sf::Text::Italic, 16);
			m_texts.push_back(error);
		}
		yOffset += 30;
	}
	// check last validator:
	Text formValidators("Form Validators:", sf::Vector2f(50, yOffset), sf::Color::Black);	
	m_texts.push_back(formValidators);
	yOffset += 30;
	for (int i = 0; i < specialErrors.size(); i++)
	{
		approved = false;
		Text error(specialErrors[i], sf::Vector2f(50, yOffset), sf::Color::Red, sf::Text::Italic, 16);		
		yOffset += 30;
	}
	yOffset += 40;	
	m_approve = ConfirmationBtn("APPROVE", sf::Vector2f(20, yOffset), sf::Color(50, 150, 50));
	m_cancel = ConfirmationBtn("CANCEL", sf::Vector2f(200, yOffset), sf::Color(180, 0, 0));
}


void ConfimationWindow::render()
{
	sf::RenderWindow confirmWindow(sf::VideoMode(500, 600), "Confirm " + formTitle);
	while (confirmWindow.isOpen()) {
		sf::Event event;
		while (confirmWindow.pollEvent(event)) {
			if (event.type == sf::Event::Closed)
				confirmWindow.close();
			sf::Vector2f mousePos(event.mouseButton.x, event.mouseButton.y);
			if (event.type == sf::Event::MouseButtonPressed) {
				// cancel clicked: 
				if (m_cancel.contains(mousePos)) {
					confirmWindow.close();
				}
				if (m_approve.contains(mousePos)) {
					if (approved)
						std::cout << formTitle << " Confirmed! Returning to main menu." << std::endl;
					confirmWindow.close();
				}
			}
		}
		for (auto& text : m_texts) {
			text.draw(confirmWindow);
		}
		m_cancel.draw(confirmWindow);
		m_approve.draw(confirmWindow);
		confirmWindow.clear(sf::Color(240, 240, 240));
	}
}

File: ConfirmationBtn.cpp
--------------------------------------------------
#include "ConfirmationBtn.h"


ConfirmationBtn::ConfirmationBtn(std::string text, sf::Vector2f location, sf::Color color)
	: Button(Text(text, sf::Vector2f(location.x + 30, location.y + 10), sf::Color::White, sf::Text::Regular, 20))
{
	m_rectangle.setSize(sf::Vector2f(140, 40));
	m_rectangle.setPosition(location);
	m_rectangle.setFillColor(color);
}

void ConfirmationBtn::update()
{

}

void ConfirmationBtn::onClick()
{
}


File: DataLoader.cpp
--------------------------------------------------
#include "DataLoader.h"

DataLoader& DataLoader::Init()
{
    static DataLoader instance;
    return instance;
}

sf::Font& DataLoader::getP2Font()
{
    auto& instance = Init();
    return instance.m_font;
}

DataLoader::DataLoader()
{
    m_font.loadFromFile("C:/Windows/Fonts/arialbd.ttf");
}


File: DatabaseManager.cpp
--------------------------------------------------
// DatabaseManager.cpp - Implements Data Storage
#include "DatabaseManager.h"

void DatabaseManager::saveBookingData(const std::string& bookingData) {
    // Save to file
}

std::vector<std::string> DatabaseManager::loadBookings() {
    // Load from file
    return {};
}


File: Date.cpp
--------------------------------------------------
#include "Date.h"

int Date::getDay() const
{
	return m_day;
}

int Date::getMonth() const
{
	return m_month;
}

int Date::getYear() const
{
	return m_year;
}

Date::Date(int day, int month, int year)
{
	m_day = day;
	m_month = month;
	m_year = year;
}
Date::Date(const Date& other)
{
	*this = other;
}

Date& Date::operator=(const Date& other)
{
	if (this != &other)
	{
		m_day = other.m_day;
		m_month = other.m_month;
		m_year = other.m_year;
	}
	return *this;
}
bool Date::operator==(const Date& other) const
{
	return (m_day == other.m_day && m_month == other.m_month && m_year == other.m_year);
}
bool Date::operator!=(const Date& other) const
{
	return !(*this == other);
}
//std::istream& operator>>(std::istream& is, Date& date)
//{
//	is >> m_day >> m_month >> m_year;
//	return is;
//}
std::ostream& operator<<(std::ostream& os, const Date& date)
{
	os << date.getDay() << "/" << date.getMonth() << "/" << date.getYear();
	return os;
}

File: DateValidator.cpp
--------------------------------------------------
#include "DateValidator.h"

bool DateValidator::validate(const Date& date) const
{
	int day = date.getDay();
	int month = date.getMonth();
	int year = date.getYear();
    if ( // check if the year is leap year. first check if the year is bigger than zero and smaller or equal to 3000.
        // the first check is if it february, check if the year is divisible to 4 and year not divisible to 100 or divisible to 400. in this case, the maximum day can be 29
        (year > 0 && year <= 3000 && day > 0) &&
        ((month == 2 && year % 4 == 0 && (year % 100 != 0 || year % 400 == 0) && day <= 29) ||
            // else this is regular year so check if month is february, the day is samller or equal to 28
            (month == 2 && day <= 28) ||
            // check for the month the days need to be smaller than 30
            (month == 4 || month == 6
                || month == 9 || month == 11) && day <= 30 ||
            // check for the month the days need to be smaller than 31.
            (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) && day <= 31))
    {
        return true;
    }
    return false;
}


File: DialogueManager.cpp
--------------------------------------------------
﻿#include "DialogueManager.h"

DialogueManager::DialogueManager() : activeForm(nullptr), isFormOpen(false) {}

void DialogueManager::setActiveForm(std::unique_ptr<BookingForm> form) {
    if (isFormOpen) return;  // Prevent multiple openings
    isFormOpen = true;

    activeForm = std::move(form);
    std::cout << "Opening " << activeForm->getFormType() << " form...\n";

    if (!formWindow.isOpen()) {  // ✅ Fix: Prevent reopening if already open

        formWindow.create(sf::VideoMode(650, 700), activeForm->getFormType());
    }
}

void DialogueManager::closeForm() {
    if (formWindow.isOpen()) {
        formWindow.close();   // ✅ Close the window
    }

    if (activeForm) {
        activeForm.reset();  // ✅ Properly delete the form
        activeForm = nullptr; // ✅ Explicitly set to nullptr to prevent dangling pointer
    }

    isFormOpen = false;   // ✅ Allow opening a new form later
    std::cout << "Returned to Main Menu.\n";
}


void DialogueManager::handleFormEvents() {
    if (!isFormOpen || !formWindow.isOpen() || !activeForm) {
        return; // ✅ Avoid handling events if form is closed
    }

    sf::Event event;
    while (formWindow.pollEvent(event)) {
        if (event.type == sf::Event::Closed) {
            closeForm();  // ✅ Use closeForm() instead of just closing the window
            return;
        }

        if (activeForm) {  // ✅ Check again before accessing
            activeForm->handleInput(event);
        }
    }

    if (activeForm) {  // ✅ Prevent access if deleted
        formWindow.clear(sf::Color::White);
        activeForm->render(formWindow);
        formWindow.display();
    }
}



File: EmailValidator.cpp
--------------------------------------------------
#include "EmailValidator.h"
#include <regex>

bool EmailValidator::validate(const std::string& email) 
{
    std::regex emailPattern(R"(^[A-Za-z0-9.-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$)");
    return std::regex_match(email, emailPattern);
}

std::string EmailValidator::getError()
{
    return "Enter Valid Email";
}


File: Engine.cpp
--------------------------------------------------
﻿#include "Engine.h"

Engine::Engine()
    : window(sf::VideoMode(500, 600), "Massive Travel Booking System"),
       uiManager(window, dialogueManager)  // ✅ Fix: Pass formManager
{
}
void Engine::run() {
    while (window.isOpen()) {
        sf::Event event;
        while (window.pollEvent(event)) {
            if (event.type == sf::Event::Closed)
                window.close();

            uiManager.handleEvent(event);
        }

        dialogueManager.handleFormEvents();  // ✅ Ensures form window updates properly

        window.clear(sf::Color(240, 240, 240));
        uiManager.render();
        window.display();
    }
}



File: EventBookingForm.cpp
--------------------------------------------------
﻿#include "EventBookingForm.h"
#include "DialogueManager.h"
#include <iostream>
#include <ctime>  // For getting current date

EventBookingForm::EventBookingForm(sf::RenderWindow& win, DialogueManager* manager)
    : BookingForm(win, manager) {  // ✅ Calls base constructor
    fieldLabels.insert(fieldLabels.end(), {
        "Event Name:", "Venue:", "Event Date:",
        "Number of Tickets:","Wheelchair Accessibility?", "Seating Preference:"
        });

    userInput.resize(fieldLabels.size(), "");  // ✅ Resize input fields
    setDefaultValues();
}

void EventBookingForm::setDefaultValues() {
    time_t now = time(0);
    tm ltm;
    localtime_s(&ltm, &now);  // ✅ Safe alternative to localtime()

    userInput[6] = std::to_string(1900 + ltm.tm_year) + "-" +
        std::to_string(1 + ltm.tm_mon) + "-" +
        std::to_string(ltm.tm_mday);
    userInput[9] = "General Admission";
}

std::string EventBookingForm::getFormType() const {
    return "Event Booking";
}

void EventBookingForm::render(sf::RenderWindow& window) {
    sf::Font font;
    font.loadFromFile("C:/Windows/Fonts/arialbd.ttf");

    window.clear(sf::Color(235, 235, 235));

    // ✅ Title
    sf::Text title("Event Booking Form", font, 26);
    title.setFillColor(sf::Color(20, 20, 20));
    title.setStyle(sf::Text::Bold);
    title.setPosition(20, 10);
    window.draw(title);

    bool cursorVisible = (cursorTimer.getElapsedTime().asMilliseconds() % 1000 < 500);

    // ✅ Render input fields dynamically
    int yOffset = 60;
    for (std::size_t i = 0; i < fieldLabels.size(); ++i) {
        sf::Text label(fieldLabels[i], font, 18);
        label.setFillColor(sf::Color(60, 60, 60));
        label.setPosition(20, yOffset);
        window.draw(label);

        sf::RectangleShape inputBox(sf::Vector2f(250, 35));
        inputBox.setPosition(250, yOffset - 5);
        inputBox.setFillColor(sf::Color::White);
        inputBox.setOutlineThickness(2);
        inputBox.setOutlineColor(i == activeField ? sf::Color(0, 120, 255) : sf::Color(160, 160, 160));
        window.draw(inputBox);

        std::string displayText = userInput[i];
        if (i == activeField && cursorVisible) {
            displayText += "|";
        }

        sf::Text inputText(displayText, font, 16);
        inputText.setFillColor(sf::Color::Black);
        inputText.setPosition(255, yOffset);
        window.draw(inputText);

        yOffset += 50;
    }
    yOffset -= 10;
    float seatingTypeButtonX = 10;
    for (int i = 0; i < SeatingTypeSelection.size(); ++i) {
        sf::RectangleShape seatButton(sf::Vector2f(150, 30));
        seatButton.setPosition(seatingTypeButtonX, yOffset);
        seatButton.setFillColor(selectedSeatingType == i ? sf::Color(0, 120, 255) : sf::Color::White);  // ✅ Highlight selected
        seatButton.setOutlineThickness(2);
        seatButton.setOutlineColor(sf::Color(160, 160, 160));
        window.draw(seatButton);

        sf::Text roomText(SeatingTypeSelection[i], font, 16);
        roomText.setFillColor(selectedSeatingType == i ? sf::Color::White : sf::Color::Black);
        roomText.setPosition(seatingTypeButtonX + 5, yOffset + 5);
        window.draw(roomText);

        seatingTypeButtonX += 160;  // ✅ Increased spacing
    }
    // ✅ "Done" and "Cancel" Buttons (positioned dynamically)
     yOffset += 50;

    sf::RectangleShape submitButton(sf::Vector2f(140, 40));
    submitButton.setPosition(20, yOffset);
    submitButton.setFillColor(sf::Color(50, 150, 50));
    window.draw(submitButton);

    sf::Text submitText("DONE", font, 20);
    submitText.setFillColor(sf::Color::White);
    submitText.setPosition(50, yOffset + 10);
    window.draw(submitText);

    sf::RectangleShape cancelButton(sf::Vector2f(140, 40));
    cancelButton.setPosition(200, yOffset);
    cancelButton.setFillColor(sf::Color(180, 0, 0));
    window.draw(cancelButton);

    sf::Text cancelText("CANCEL", font, 20);
    cancelText.setFillColor(sf::Color::White);
    cancelText.setPosition(230, yOffset + 10);
    window.draw(cancelText);
}

void EventBookingForm::handleInput(sf::Event event) {
    if (event.type == sf::Event::TextEntered) {
        if (event.text.unicode == '\b' && !userInput[activeField].empty()) {
            userInput[activeField].pop_back();
        }
        else if (event.text.unicode >= 32 && event.text.unicode < 128) {
            userInput[activeField] += static_cast<char>(event.text.unicode);
        }
    }
    else if (event.type == sf::Event::KeyPressed) {
        if (event.key.code == sf::Keyboard::Tab) {
            activeField = (activeField + 1) % userInput.size();
        }
        if (event.key.code == sf::Keyboard::Return) {
            std::cout << "Entered Data: ";
            for (const auto& field : userInput) std::cout << field << " ";
            std::cout << std::endl;
        }
    }
    else if (event.type == sf::Event::MouseButtonPressed) {
        sf::Vector2f mousePos(event.mouseButton.x, event.mouseButton.y);
        int yOffset = 60;

        for (std::size_t i = 0; i < fieldLabels.size(); ++i) {
            sf::FloatRect inputBoxBounds(250, yOffset - 5, 250, 35);
            if (inputBoxBounds.contains(mousePos)) {
                activeField = i;
                return;
            }
            yOffset += 50;
        }
        // ✅ Handle Seating Type Button Click     
        yOffset -= 10;    
        float seatingButtonX = 10;
        for (int i = 0; i < SeatingTypeSelection.size(); ++i) {
            sf::FloatRect timeButtonBounds(seatingButtonX, yOffset, 150, 30);
            if (timeButtonBounds.contains(mousePos)) {
                selectedSeatingType = i;
                //Update the "Room Type" input box
                userInput[9] = SeatingTypeSelection[i];

                return;
            }
            seatingButtonX += 160;  // Move to next button
        }

        yOffset += 50;

        if (mousePos.x >= 20 && mousePos.x <= 160 && mousePos.y >= yOffset && mousePos.y <= yOffset + 40) {
            std::cout << "Event Booking Confirmed!\n";
            openConfirmationWindow();
            return;
        }

        if (mousePos.x >= 200 && mousePos.x <= 340 && mousePos.y >= yOffset && mousePos.y <= yOffset + 40) {
            std::cout << "Cancelled Event Booking\n";
            formManager->closeForm();
            return;
        }
    }
}


File: FlightBookingForm.cpp
--------------------------------------------------
﻿#include "FlightBookingForm.h"
#include "DialogueManager.h"
#include <iostream>
#include <ctime>  // For getting current date

FlightBookingForm::FlightBookingForm(sf::RenderWindow& win, DialogueManager* manager)
    : BookingForm(win,manager) {  // ✅ Calls base constructor
    fieldLabels.insert(fieldLabels.end(), { "Departure Airport:", "Arrival Airport:",
                   "Departure Date:",
                   "Preferred Time:" });
    userInput.resize(fieldLabels.size(), "");  // Resize to include all fields
    setDefaultValues();
}
    

void FlightBookingForm::setDefaultValues() {
    time_t now = time(0);
    tm ltm;
    localtime_s(&ltm, &now);  // ✅ Safe alternative to localtime()

    userInput[6] = std::to_string(1900 + ltm.tm_year) + "-" +
        std::to_string(1 + ltm.tm_mon) + "-" +
        std::to_string(ltm.tm_mday);

	userInput[7] = "Don'Type Care";  // ✅ Default time selection
}

std::string FlightBookingForm::getFormType() const {
    return "Flight Booking";
}

void FlightBookingForm::render(sf::RenderWindow& window) {
    sf::Font font;
    font.loadFromFile("C:/Windows/Fonts/arialbd.ttf");
      
    window.clear(sf::Color(235, 235, 235));

    // ✅ Title
    sf::Text title("Flight Booking Form", font, 26);
    title.setFillColor(sf::Color(20, 20, 20));
    title.setStyle(sf::Text::Bold);
    title.setPosition(20, 10);
    window.draw(title);

    bool cursorVisible = (cursorTimer.getElapsedTime().asMilliseconds() % 1000 < 500);

    // ✅ Loop through form fields and render
    int yOffset = 60;
    for (std::size_t i = 0; i < fieldLabels.size(); ++i) {
        sf::Text label(fieldLabels[i], font, 18);
        label.setFillColor(sf::Color(60, 60, 60));
        label.setPosition(20, yOffset);
        window.draw(label);

        sf::RectangleShape inputBox(sf::Vector2f(350, 35));
        inputBox.setPosition(240, yOffset - 5);
        inputBox.setFillColor(sf::Color::White);
        inputBox.setOutlineThickness(2);
        inputBox.setOutlineColor(i == activeField ? sf::Color(0, 120, 255) : sf::Color(160, 160, 160));
        window.draw(inputBox);

        std::string displayText = userInput[i];
        if (i == activeField && cursorVisible) {
            displayText += "|";
        }

        sf::Text inputText(displayText, font, 16);
        inputText.setFillColor(sf::Color::Black);
        inputText.setPosition(245, yOffset);
        window.draw(inputText);  

        yOffset += 50;
    }

    // ✅ Time Selection Buttons
    //   
    float timeButtonX = 10;
    for (std::size_t i = 0; i < timeSelection.size(); ++i) {
        sf::RectangleShape timeButton(sf::Vector2f(100, 30));
        timeButton.setPosition(timeButtonX, yOffset);
        timeButton.setFillColor(timeSelection[i].second ? sf::Color(0, 120, 255) : sf::Color::White);
        timeButton.setOutlineThickness(2);
        timeButton.setOutlineColor(sf::Color(160, 160, 160));
        window.draw(timeButton);

        sf::Text timeText(timeSelection[i].first, font, 16);
        timeText.setFillColor(timeSelection[i].second ? sf::Color::White : sf::Color::Black);
        timeText.setPosition(timeButtonX + 10, yOffset+2);
        window.draw(timeText);

        timeButtonX += 110;  // ✅ Increased spacing between buttons
    }


    // ✅ "Done" Button
    sf::RectangleShape submitButton(sf::Vector2f(140, 40));
    submitButton.setPosition(20, 550);
    submitButton.setFillColor(sf::Color(50, 150, 50));  // ✅ Green color
    window.draw(submitButton);

    sf::Text submitText("DONE", font, 20);
    submitText.setFillColor(sf::Color::White);
    submitText.setPosition(50, 560);
    window.draw(submitText);

    // ✅ "Cancel" Button
    sf::RectangleShape cancelButton(sf::Vector2f(140, 40));
    cancelButton.setPosition(200, 550);
    cancelButton.setFillColor(sf::Color(180, 0, 0));  // ✅ Red color
    window.draw(cancelButton);

    sf::Text cancelText("CANCEL", font, 20);
    cancelText.setFillColor(sf::Color::White);
    cancelText.setPosition(230, 560);
    window.draw(cancelText);

}


void FlightBookingForm::handleInput(sf::Event event) {
    if (event.type == sf::Event::TextEntered) {
        if (event.text.unicode == '\b' && !userInput[activeField].empty()) { 
            userInput[activeField].pop_back();  // ✅ Handle Backspace
        } 
        else if (event.text.unicode >= 32 && event.text.unicode < 128) {
            userInput[activeField] += static_cast<char>(event.text.unicode);  // ✅ Append typed character
        }
    } 
    else if (event.type == sf::Event::KeyPressed) {
        if (event.key.code == sf::Keyboard::Tab) {
            activeField = (activeField + 1) % userInput.size();  // ✅ Move to next input field
        }
        if (event.key.code == sf::Keyboard::Return) {
            std::cout << "Entered Data: ";
            for (const auto& field : userInput) std::cout << field << " ";
            std::cout << std::endl;
        }
    }
    else if (event.type == sf::Event::MouseButtonPressed) {
        sf::Vector2f mousePos(event.mouseButton.x, event.mouseButton.y);

        int yOffset = 60;  // ✅ Start from the top

        for (std::size_t i = 0; i < fieldLabels.size(); ++i) {
            sf::FloatRect inputBoxBounds(260, yOffset - 5, 250, 35);  // ✅ Uses dynamic positioning
            if (inputBoxBounds.contains(mousePos)) {
                activeField = i;
                return;
            }
            yOffset += 50;  // ✅ Move down dynamically (same logic as `render()`)
        }


        // ✅ Handle Time Selection Button Click          
        float timeButtonX = 10;
               
        for (int i = 0; i < 5; ++i) {           
            sf::FloatRect timeButtonBounds(timeButtonX, yOffset, 100, 30);
            if (timeButtonBounds.contains(mousePos)) {                
                timeSelection[i].second = !timeSelection[i].second;
                //Update the "Preferred Time" input box
                userInput[7] = "";
                for (int i = 0; i < 5; ++i) {
                    if (timeSelection[i].second) {
                        if (!userInput[7].empty()) userInput[7] += "| ";  // ✅ Separate multiple selections
                        userInput[7] += timeSelection[i].first;
                    }
                }

                return;
            }
            timeButtonX += 110;  // Move to next button
            
            
        }
    

        // ✅ Handle "Done" Button Click
        if (mousePos.x >= 20 && mousePos.x <= 160 && mousePos.y >= 550 && mousePos.y <= 590) {
            std::cout << "Flight Booking Confirmed!\n";
            openConfirmationWindow();  // ✅ Open confirmation
            return;
        }

        // ✅ Handle "Cancel" Button Click
        if (mousePos.x >= 200 && mousePos.x <= 340 && mousePos.y >= 550 && mousePos.y <= 590) {
            std::cout << "Cancelled Flight Booking\n";
            formManager->closeForm();
            return;
        }
    }

}








File: HotelBookingForm.cpp
--------------------------------------------------
﻿#include "HotelBookingForm.h"
#include "DialogueManager.h"
#include <iostream>
#include <ctime>  // For getting current date

HotelBookingForm::HotelBookingForm(sf::RenderWindow& win, DialogueManager* manager)
    : BookingForm(win, manager) {  // ✅ Calls base constructor
    fieldLabels.insert(fieldLabels.end(), {
        "Hotel Name:", "Check-in Date:", "Check-out Date:",
        "Number of Guests:", "Room Type:"
        });

    userInput.resize(fieldLabels.size(), "");  // ✅ Resize input fields
    setDefaultValues();
}

void HotelBookingForm::setDefaultValues() {
    time_t now = time(0);
    tm ltm;
    localtime_s(&ltm, &now);  // ✅ Safe alternative to localtime()

    userInput[5] = userInput[6] = std::to_string(1900 + ltm.tm_year) + "-" +
        std::to_string(1 + ltm.tm_mon) + "-" +
        std::to_string(ltm.tm_mday);
    userInput[8]="Single Room";
}

std::string HotelBookingForm::getFormType() const {
    return "Hotel Booking";
}

void HotelBookingForm::render(sf::RenderWindow& window) {
    sf::Font font;
    font.loadFromFile("C:/Windows/Fonts/arialbd.ttf");

    window.clear(sf::Color(235, 235, 235));

    // ✅ Title
    sf::Text title("Hotel Booking Form", font, 26);
    title.setFillColor(sf::Color(20, 20, 20));
    title.setStyle(sf::Text::Bold);
    title.setPosition(20, 10);
    window.draw(title);

    bool cursorVisible = (cursorTimer.getElapsedTime().asMilliseconds() % 1000 < 500);

    // ✅ Render input fields dynamically
    int yOffset = 60;
    for (std::size_t i = 0; i < fieldLabels.size(); ++i) {
        sf::Text label(fieldLabels[i], font, 18);
        label.setFillColor(sf::Color(60, 60, 60));
        label.setPosition(20, yOffset);
        window.draw(label);

        sf::RectangleShape inputBox(sf::Vector2f(250, 35));
        inputBox.setPosition(240, yOffset - 5);
        inputBox.setFillColor(sf::Color::White);
        inputBox.setOutlineThickness(2);
        inputBox.setOutlineColor(i == activeField ? sf::Color(0, 120, 255) : sf::Color(160, 160, 160));
        window.draw(inputBox);

        std::string displayText = userInput[i];
        if (i == activeField && cursorVisible) {
            displayText += "|";
        }

        sf::Text inputText(displayText, font, 16);
        inputText.setFillColor(sf::Color::Black);
        inputText.setPosition(245, yOffset);
        window.draw(inputText);

        yOffset += 50;
    }
    float roomTypeButtonX = 10;
    for (int i = 0; i < roomTypeSelection.size(); ++i) {
        sf::RectangleShape roomButton(sf::Vector2f(150, 30));
        roomButton.setPosition(roomTypeButtonX, yOffset);
        roomButton.setFillColor(selectedRoomType==i ? sf::Color(0, 120, 255) : sf::Color::White);  // ✅ Highlight selected
        roomButton.setOutlineThickness(2);
        roomButton.setOutlineColor(sf::Color(160, 160, 160));
        window.draw(roomButton);

        sf::Text roomText(roomTypeSelection[i], font, 16);
        roomText.setFillColor(selectedRoomType == i ? sf::Color::White : sf::Color::Black);
        roomText.setPosition(roomTypeButtonX + 10, yOffset + 5);
        window.draw(roomText);

        roomTypeButtonX += 160;  // ✅ Increased spacing
    }
    // ✅ "Done" Button
    sf::RectangleShape submitButton(sf::Vector2f(140, 40));
    submitButton.setPosition(20, 570);
    submitButton.setFillColor(sf::Color(50, 150, 50));  // ✅ Green color
    window.draw(submitButton);

    sf::Text submitText("DONE", font, 20);
    submitText.setFillColor(sf::Color::White);
    submitText.setPosition(50, 580);
    window.draw(submitText);

    // ✅ "Cancel" Button
    sf::RectangleShape cancelButton(sf::Vector2f(140, 40));
    cancelButton.setPosition(200, 570);
    cancelButton.setFillColor(sf::Color(180, 0, 0));  // ✅ Red color
    window.draw(cancelButton);

    sf::Text cancelText("CANCEL", font, 20);
    cancelText.setFillColor(sf::Color::White);
    cancelText.setPosition(230, 580);
    window.draw(cancelText);

}

void HotelBookingForm::handleInput(sf::Event event) {
    if (event.type == sf::Event::TextEntered) {
        if (event.text.unicode == '\b' && !userInput[activeField].empty()) {
            userInput[activeField].pop_back();
        }
        else if (event.text.unicode >= 32 && event.text.unicode < 128) {
            userInput[activeField] += static_cast<char>(event.text.unicode);
        }
    }
    else if (event.type == sf::Event::KeyPressed) {
        if (event.key.code == sf::Keyboard::Tab) {
            activeField = (activeField + 1) % userInput.size();
        }
        if (event.key.code == sf::Keyboard::Return) {
            std::cout << "Entered Data: ";
            for (const auto& field : userInput) std::cout << field << " ";
            std::cout << std::endl;
        }
    }
    else if (event.type == sf::Event::MouseButtonPressed) {
        sf::Vector2f mousePos(event.mouseButton.x, event.mouseButton.y);

        int yOffset = 60;  // ✅ Start from the top

        for (std::size_t i = 0; i < fieldLabels.size(); ++i) {
            sf::FloatRect inputBoxBounds(260, yOffset - 5, 250, 35);  // ✅ Uses dynamic positioning
            if (inputBoxBounds.contains(mousePos)) {
                activeField = i;
                return;
            }
            yOffset += 50;  // ✅ Move down dynamically (same logic as `render()`)
        }


        // ✅ Handle Room Type Button Click          
        float roomButtonX = 10;
                for (int i = 0; i < roomTypeSelection.size(); ++i) {
            sf::FloatRect timeButtonBounds(roomButtonX, yOffset, 150, 30);
            if (timeButtonBounds.contains(mousePos)) {
				selectedRoomType = i;
                //Update the "Room Type" input box
                userInput[8] = roomTypeSelection[i];             

                return;
            }
            roomButtonX += 160;  // Move to next button
        }


        // ✅ Handle "Done" Button Click
        if (mousePos.x >= 20 && mousePos.x <= 160 && mousePos.y >= 570 && mousePos.y <= 610) {
            std::cout << "Flight Booking Confirmed!\n";
            openConfirmationWindow();  // ✅ Open confirmation
            return;
        }

        // ✅ Handle "Cancel" Button Click
        if (mousePos.x >= 200 && mousePos.x <= 340 && mousePos.y >= 570 && mousePos.y <= 610) {
            std::cout << "Cancelled Flight Booking\n";
            formManager->closeForm();
            return;
        }
    }
}


File: IDValidator.cpp
--------------------------------------------------
#include "IDValidator.h"



bool IDValidator::validate(const uint32_t& fieldToValidate)
{
    int sum = 0, incNum;
    uint32_t numArr[9] = { 0 };
    uint32_t tmp = fieldToValidate;

    // check the length of the number
    if (fieldToValidate < 100000000 || fieldToValidate > 999999999) {
        return false;
    }

    // convert the number to an array for easy check later
    for (int i = 8; i >= 0; i--) {
        numArr[i] = tmp % 10;
        tmp = tmp / 10;
    }

    // validate the id number
    for (int i = 0; i < 9; i++) {
        incNum = numArr[i] * ((i % 2) + 1);
        sum += (incNum > 9) ? incNum - 9 : incNum;
    }
    if (sum % 10 == 0) {
        return true;
    }

    return false;

}

std::string IDValidator::getError()
{
    return "Not valid ID";
}


File: Logger.cpp
--------------------------------------------------
// Logger.cpp - Implements System Logging
#include "Logger.h"

Logger* Logger::instance = nullptr;
std::mutex Logger::mutex;

Logger::Logger() {
    logFile.open("system.log", std::ios::app);
    if (!logFile) {
        std::cerr << "Error: Unable to open log file." << std::endl;
    }
}

Logger* Logger::getInstance() {
    if (instance == nullptr) {
        std::lock_guard<std::mutex> lock(mutex);
        if (instance == nullptr) {
            instance = new Logger();
        }
    }
    return instance;
}

void Logger::log(const std::string& message) {
    std::lock_guard<std::mutex> lock(mutex);
    if (logFile) {
        std::time_t now = std::time(nullptr);
        char timeBuffer[26]; // Buffer for formatted time
        ctime_s(timeBuffer, sizeof(timeBuffer), &now);
        logFile << "[" << timeBuffer << "] " << message << std::endl;

    }
}

Logger::~Logger() {
    if (logFile) {
        logFile.close();
    }
}


File: NameValidator.cpp
--------------------------------------------------
#include "NameValidator.h"

bool NameValidator::validate(const std::string& name)
{
	for (int index = 0; index < name.length(); index++)
		if (isdigit(name[index])) return false;
	return true;
}

std::string NameValidator::getError()
{
	return "No digits Allowed";
}


File: NotificationSystem.cpp
--------------------------------------------------
// NotificationSystem.cpp - Implements Notification Sending
#include "NotificationSystem.h"

void NotificationSystem::sendNotification(const std::string& message) {
    // Send email or push notification
}


File: SelectionButton.cpp
--------------------------------------------------
#include "SelectionButton.h"

SelectionButton::SelectionButton(const std::string& text, sf::Vector2f location) : 
	Button(Text(text,sf::Vector2f(location.x + 10 , location.y +5) , sf::Color::Black , sf::Text::Regular, 16))
{
	m_rectangle.setSize(sf::Vector2f(90, 30));
	m_rectangle.setPosition(location);
	m_rectangle.setFillColor(sf::Color::White);
	m_rectangle.setOutlineThickness(2);
	m_rectangle.setOutlineColor(sf::Color(160, 160, 160));
}

void SelectionButton::setClick(bool input)
{
	m_isClicked = input;
}

void SelectionButton::update()
{ 
	if (m_isClicked)
	{
		m_rectangle.setFillColor(sf::Color(0, 120, 255));
		m_text.setFillColor(sf::Color::White);
	}
	else
	{
		m_rectangle.setFillColor(sf::Color::White);
		m_text.setFillColor(sf::Color::Black);
	}
}

void SelectionButton::onClick()
{
	//TODO
}

std::string SelectionButton::getText()
{	
	return m_text.getString();
}


File: SelectionField.cpp
--------------------------------------------------
#include "SelectionField.h"


SelectionField::SelectionField(std::unique_ptr<BaseField> field, std::vector<std::unique_ptr<SelectionButton>> buttons)
	:m_buttons(std::move(buttons))
{
	m_field = std::move(field);
}

SelectionField::SelectionField()
	: m_field(std::make_unique<Field<NameValidator, std::string>>("")), m_buttons()
{
}

void SelectionField::update(const sf::Time& time)
{
	for (auto& button : m_buttons)
		button.get()->update();

}

bool SelectionField::contains(sf::Vector2f& coords)
{
	for (auto& button : m_buttons) {
		if (button.get()->contains(coords))
			return true;
	}
	return false;
}

void SelectionField::draw(sf::RenderWindow& window)
{
	m_field.get()->draw(window);
	for (auto& button : m_buttons)
		button.get()->draw(window);

}

void SelectionField::handleEvent(sf::Event& event)
{
	for (auto& button : m_buttons)
	{
		sf::Vector2f loc = sf::Vector2f(event.mouseButton.x, event.mouseButton.y);
		if (button.get()->contains(loc))
		{
			m_field.get()->setText(button.get()->getText());
			button.get()->setClick(true);
		}
		else {
			button.get()->setClick(false);
		}
	}
}

File: Text.cpp
--------------------------------------------------
#include "Text.h"

Text::Text(std::string text, sf::Vector2f location, sf::Color color, sf::Text::Style style,
	unsigned int characterSize)
{
	m_text.setString(text);
	m_text.setFillColor(color);
	m_text.setStyle(style);
	m_text.setCharacterSize(characterSize);
	m_text.setFont(DataLoader::getP2Font());
	m_text.setPosition(location);
}

void Text::draw(sf::RenderWindow& window)
{

	window.draw(m_text);
}


void Text::setText(std::string text)
{
	m_text.setString(text);
}

void Text::setLocation(sf::Vector2f newLocation)
{
	m_text.setPosition(newLocation);
}

void Text::setFillColor(const sf::Color& color)
{
	m_text.setFillColor(color);
}

sf::Text& Text::getText()
{
	return m_text;
}

std::string Text::getString()
{
	return m_text.getString();
}


File: TrainBookingForm.cpp
--------------------------------------------------
﻿#include "TrainBookingForm.h"
#include "DialogueManager.h"
#include <iostream>
#include <ctime>  // For getting current date

TrainBookingForm::TrainBookingForm(sf::RenderWindow& win, DialogueManager* manager)
    : BookingForm(win, manager) {  // ✅ Calls base constructor
    fieldLabels.insert(fieldLabels.end(), {
        "Departure Station:", "Arrival Station:", "Departure Date:",
        "Number of Passengers:","Preferred Time:", "Special Requests:", 
        });

    userInput.resize(fieldLabels.size(), "");  // ✅ Resize input fields
    setDefaultValues();
}

void TrainBookingForm::setDefaultValues() {
    time_t now = time(0);
    tm ltm;
    localtime_s(&ltm, &now);  // ✅ Safe alternative to localtime()

    userInput[6] = std::to_string(1900 + ltm.tm_year) + "-" +
        std::to_string(1 + ltm.tm_mon) + "-" +
        std::to_string(ltm.tm_mday);
	userInput[8] = "Don'Type Care";
    userInput[9] = "None";
}

std::string TrainBookingForm::getFormType() const {
    return "Train Booking";
}

void TrainBookingForm::render(sf::RenderWindow& window) {
    sf::Font font;
    font.loadFromFile("C:/Windows/Fonts/arialbd.ttf");

    window.clear(sf::Color(235, 235, 235));

    // ✅ Title
    sf::Text title("Train Booking Form", font, 26);
    title.setFillColor(sf::Color(20, 20, 20));
    title.setStyle(sf::Text::Bold);
    title.setPosition(20, 10);
    window.draw(title);

    bool cursorVisible = (cursorTimer.getElapsedTime().asMilliseconds() % 1000 < 500);

    // ✅ Render input fields dynamically
    int yOffset = 60;
    for (std::size_t i = 0; i < fieldLabels.size(); ++i) {
        sf::Text label(fieldLabels[i], font, 18);
        label.setFillColor(sf::Color(60, 60, 60));
        label.setPosition(20, yOffset);
        window.draw(label);

        sf::RectangleShape inputBox(sf::Vector2f(350, 35));
        inputBox.setPosition(240, yOffset - 5);
        inputBox.setFillColor(sf::Color::White);
        inputBox.setOutlineThickness(2);
        inputBox.setOutlineColor(i == activeField ? sf::Color(0, 120, 255) : sf::Color(160, 160, 160));
        window.draw(inputBox);

        std::string displayText = userInput[i];
        if (i == activeField && cursorVisible) {
            displayText += "|";
        }

        sf::Text inputText(displayText, font, 16);
        inputText.setFillColor(sf::Color::Black);
        inputText.setPosition(245, yOffset);
        window.draw(inputText);

        if (i == 8)
        {
            yOffset += 40;
            // ✅ Time Selection Buttons
            float timeButtonX = 10;
            for (std::size_t i = 0; i < timeSelection.size(); ++i) {
                sf::RectangleShape timeButton(sf::Vector2f(100, 30));
                timeButton.setPosition(timeButtonX, yOffset);
                timeButton.setFillColor(timeSelection[i].second ? sf::Color(0, 120, 255) : sf::Color::White);
                timeButton.setOutlineThickness(2);
                timeButton.setOutlineColor(sf::Color(160, 160, 160));
                window.draw(timeButton);

                sf::Text timeText(timeSelection[i].first, font, 16);
                timeText.setFillColor(timeSelection[i].second ? sf::Color::White : sf::Color::Black);
                timeText.setPosition(timeButtonX + 10, yOffset + 2);
                window.draw(timeText);

                timeButtonX += 110;  // ✅ Increased spacing between buttons
            }
        } 
        if (i == 9)
        {
            yOffset += 40;
			// ✅ Special Selection Buttons
            float specialX = 10;
            for (std::size_t i = 0; i < specialSelection.size(); ++i) {
                sf::RectangleShape sButton(sf::Vector2f(150, 30));
                sButton.setPosition(specialX, yOffset);
                sButton.setFillColor(specialSelection[i].second ? sf::Color(0, 120, 255) : sf::Color::White);
                sButton.setOutlineThickness(2);
                sButton.setOutlineColor(sf::Color(160, 160, 160));
                window.draw(sButton);

                sf::Text timeText(specialSelection[i].first, font, 16);
                timeText.setFillColor(specialSelection[i].second ? sf::Color::White : sf::Color::Black);
                timeText.setPosition(specialX + 10, yOffset + 2);
                window.draw(timeText);

                specialX+= 160;  // ✅ Increased spacing between buttons
            }
        }
       
      yOffset += 50;
    }
   
    // ✅ "Done" and "Cancel" Buttons (positioned dynamically)
    yOffset +=10;

    sf::RectangleShape submitButton(sf::Vector2f(140, 40));
    submitButton.setPosition(20, yOffset);
    submitButton.setFillColor(sf::Color(50, 150, 50));
    window.draw(submitButton);

    sf::Text submitText("DONE", font, 20);
    submitText.setFillColor(sf::Color::White);
    submitText.setPosition(50, yOffset + 10);
    window.draw(submitText);

    sf::RectangleShape cancelButton(sf::Vector2f(140, 40));
    cancelButton.setPosition(200, yOffset);
    cancelButton.setFillColor(sf::Color(180, 0, 0));
    window.draw(cancelButton);

    sf::Text cancelText("CANCEL", font, 20);
    cancelText.setFillColor(sf::Color::White);
    cancelText.setPosition(230, yOffset + 10);
    window.draw(cancelText);
}

void TrainBookingForm::handleInput(sf::Event event) {
    if (event.type == sf::Event::TextEntered) {
        if (event.text.unicode == '\b' && !userInput[activeField].empty()) {
            userInput[activeField].pop_back();
        }
        else if (event.text.unicode >= 32 && event.text.unicode < 128) {
            userInput[activeField] += static_cast<char>(event.text.unicode);
        }
    }
    else if (event.type == sf::Event::KeyPressed) {
        if (event.key.code == sf::Keyboard::Tab) {
            activeField = (activeField + 1) % userInput.size();
        }
        if (event.key.code == sf::Keyboard::Return) {
            std::cout << "Entered Data: ";
            for (const auto& field : userInput) std::cout << field << " ";
            std::cout << std::endl;
        }
    }
    else if (event.type == sf::Event::MouseButtonPressed) {
        sf::Vector2f mousePos(event.mouseButton.x, event.mouseButton.y);
        int yOffset = 60, timeOffset = 0, specialOffset = 0;
        for (std::size_t i = 0; i < fieldLabels.size(); ++i) {
            sf::FloatRect inputBoxBounds(240, yOffset - 5, 250, 35);
            if (inputBoxBounds.contains(mousePos)) {
                activeField = i;
                return;
            }
            if (i ==8)            
                timeOffset= yOffset +=40;
            if (i==9)
                specialOffset = yOffset +=40;
            yOffset += 50;
        }
        // ✅ Handle Time Selection Button Click          
        float timeButtonX = 10;

		for (int i = 0; i < timeSelection.size(); ++i) {
            sf::FloatRect timeButtonBounds(timeButtonX, timeOffset, 100, 30);
            if (timeButtonBounds.contains(mousePos)) {
                timeSelection[i].second = !timeSelection[i].second;
                //Update the "Preferred Time" input box
                userInput[8] = "";
                for (int i = 0; i < timeSelection.size(); ++i) {
                    if (timeSelection[i].second) {
                        if (!userInput[8].empty()) userInput[8] += "| ";  // ✅ Separate multiple selections
                        userInput[8] += timeSelection[i].first;
                    }
                }

                return;
            }
            timeButtonX += 110;  // Move to next button
        }
        // ✅ Handle Special Selection Botton click
        float sButtonX = 10;

		for (int i = 0; i < specialSelection.size(); ++i) {
            sf::FloatRect specialSelectionBounds(sButtonX, specialOffset, 150, 30);
            if (specialSelectionBounds.contains(mousePos)) {
                specialSelection[i].second = !specialSelection[i].second;
                //Update the "Preferred Time" input box
                userInput[9] = "";
                for (int i = 0; i < specialSelection.size(); ++i) {
                    if (specialSelection[i].second) {
                        if (!userInput[9].empty()) userInput[9] += "| ";  // ✅ Separate multiple selections
                        userInput[9] += specialSelection[i].first;
                    }
                }

                return;
            }
            sButtonX += 160;  // Move to next button
            
        }
        yOffset += 10;

        if (mousePos.x >= 20 && mousePos.x <= 160 && mousePos.y >= yOffset && mousePos.y <= yOffset + 40) {
            std::cout << "Train Booking Confirmed!\n";
            openConfirmationWindow();
            return;
        }

        if (mousePos.x >= 200 && mousePos.x <= 340 && mousePos.y >= yOffset && mousePos.y <= yOffset + 40) {
            std::cout << "Cancelled Train Booking\n";
            formManager->closeForm();
            return;
        }
    }
}


File: UIManager.cpp
--------------------------------------------------
﻿#include "UIManager.h"
#include <iostream>
#include "FlightBookingForm.h"
#include "HotelBookingForm.h"
#include "CarRentalForm.h"
#include "EventBookingForm.h"
#include "TrainBookingForm.h"

UIManager::UIManager(sf::RenderWindow& win, DialogueManager& dManager)
    : window(win), formManager(dManager) {

 
    font.loadFromFile("C:/Windows/Fonts/arialbd.ttf");
    
    
    // ✅ Fix: Setup all buttons using setupButton()
    setupButton(buttonFlight, textFlight, "Flight Booking", 150);
    setupButton(buttonHotel, textHotel, "Hotel Booking", 220);
    setupButton(buttonCar, textCar, "Car Rental", 290);
    setupButton(buttonEvent, textEvent, "Event Booking", 360);
    setupButton(buttonTrain, textTrain, "Train Booking", 430);

}

// ✅ Fix: Define `setupButton()`
void UIManager::setupButton(sf::RectangleShape& button, sf::Text& text, const std::string& label, float y) {
    button.setSize(sf::Vector2f(300, 50));
    button.setFillColor(sf::Color::Blue);
    button.setPosition(100, y);
    
    text.setFont(font);  // ✅ Fix: Use class member `font`
    text.setString(label);
    text.setCharacterSize(24);
    text.setFillColor(sf::Color::White);
    text.setPosition(120, y + 10);
}

// ✅ Fix: Ensure render() uses class member buttons
void UIManager::render() {
    sf::Text title("Travel Booking System", font, 30);
    title.setFillColor(sf::Color::Black);
    title.setStyle(sf::Text::Bold);
    title.setPosition(80, 20);
    window.draw(title);

    // ✅ Draw all buttons
    window.draw(buttonFlight);
    window.draw(textFlight);
    window.draw(buttonHotel);
    window.draw(textHotel);
    window.draw(buttonCar);
    window.draw(textCar);
    window.draw(buttonEvent);
    window.draw(textEvent);
    window.draw(buttonTrain);
    window.draw(textTrain);
}


void UIManager::handleEvent(const sf::Event& event) {
    if (event.type == sf::Event::MouseButtonPressed) {
        sf::Vector2f mousePos(event.mouseButton.x, event.mouseButton.y);
        std::cout << "Mouse Clicked at: " << mousePos.x << ", " << mousePos.y << std::endl;  // ✅ Debug log

        if (buttonFlight.getGlobalBounds().contains(mousePos)) {
            std::cout << "Flight Booking Button Clicked!" << std::endl;  // ✅ Debug
            formManager.setActiveForm(std::make_unique<FlightBookingForm>(window, &formManager));
        }

        if (buttonHotel.getGlobalBounds().contains(mousePos)) {
            std::cout << "Hotel Booking Button Clicked!" << std::endl;
            formManager.setActiveForm(std::make_unique<HotelBookingForm>(window, &formManager));
        }

        if (buttonCar.getGlobalBounds().contains(mousePos)) {
            std::cout << "Car Rental Button Clicked!" << std::endl;
            formManager.setActiveForm(std::make_unique<CarRentalForm>(window, &formManager));
        }

        if (buttonEvent.getGlobalBounds().contains(mousePos)) {
            std::cout << "Event Booking Button Clicked!" << std::endl;
            formManager.setActiveForm(std::make_unique<EventBookingForm>(window, &formManager));
        }

        if (buttonTrain.getGlobalBounds().contains(mousePos)) {
            std::cout << "Train Booking Button Clicked!" << std::endl;
            formManager.setActiveForm(std::make_unique<TrainBookingForm>(window, &formManager));
        }
        
    }
}


File: main.cpp
--------------------------------------------------
﻿// main.cpp - Entry Point
#include "Engine.h"
#include <SFML/Graphics.hpp>

int main() {
    Engine engine;  //  Create the Engine instance
    engine.run();   //  Start the loop inside Engine
    return 0;
}



